\documentclass[11pt,twoside,a4paper]{article}

%========== PACKAGES ==========%

\usepackage{a4wide}                  % for a wider layout
\usepackage[danish]{babel}           % for correct language
\usepackage{color}                   % for color declarations
\usepackage{fancyhdr}                % for layout and design
\usepackage{float}                   % for the [H] position specifier
\usepackage[utf8]{inputenc}          % for UTF-8 encoding
\usepackage{listings}                % for code examples
\usepackage{mips}                    % for MIPS syntax highlighting
\usepackage{multicol}                % for multicolumn layouts


%========== DEFINITIONS ==========%

\definecolor{c_comment}{rgb}        {0.38, 0.62, 0.38}
\definecolor{c_keyword}{rgb}        {0.10, 0.10, 0.81}
\definecolor{c_identifier}{rgb}     {0.00, 0.00, 0.00}
\definecolor{c_string}{rgb}         {0.50, 0.50, 0.50}


%========== MACROS ==========%

\newcommand{\figref[1]}{se Figur~\ref{#1}}  % use for referencing figures

%========== SETTINGS ==========%

\lstset
{
        numbers=left,
        frame=single,
        basicstyle=\footnotesize\ttfamily,
        tabsize=4,
        % colors
        commentstyle=\color{c_comment},
        keywordstyle=\color{c_keyword},
        identifierstyle=\color{c_identifier},
        stringstyle=\color{c_string},
}


%========== DECLARATIONS ==========%

\title
{
        \vspace{0.0in}        % if more space is needed for abstract/toc adjust this
        Machine Architecture\\
        \Large Assignment 2
}

\author
{
        Casper B. Hansen\\
        University of Copenhagen\\
        Department of Computer Science\\
        {\tt fvx507@alumni.ku.dk}
        \and
        Sine Vestergård Jensen\\
        University of Copenhagen\\
        Department of Computer Science\\
        {\tt kms698@alumni.ku.dk}
        \and
        Nikolaj Høyer\\
        University of Copenhagen\\
        Department of Computer Science\\
        {\tt ctl533@alumni.ku.dk}
}

\date{\today}

%========== DOCUMENT ==========%

\begin{document}

\clearpage
\maketitle
\thispagestyle{empty}
\hrule
\vspace{0.5in}        % spacing between title/authors and abstract/toc
\begin{multicols}{2}
\begin{abstract}
\noindent Følgende beskriver løsning af G2 gruppeopgaven til maskinarkitektur
på Københavns Universitet, samt forløbet af udarbejdelsen heraf.

Ved at tage udgangspunkt i et simplere kredsløb, nemlig {\it single-cycle}
kredsløbet, forsimplede vi omfanget af opgaven om, at bygge et {\it pipelined}
processor kredsløb, som understøtter en delmængde af MIPS\footnote{MIPS -
http://en.wikipedia.org/wiki/MIPS\_architecture} instruktionssættet.

Efter vi havde en fungerende implementation af {\it single-cycle} kredsløbet,
indførte vi {\it pipes}, som effektivt delte kredsløbet op i
eksekveringsstadier, og herefter løste vi de introducerede {\it hazards} i
logisk rækkefølge af deres forekomst.

Under hver udbedring af hvert stadie opfulgte vi med at teste kredsløbet, og
reitererede løsningen, om nødvendigt.

Sidst opfulgte vi med omfattende tests af det endelige kredsløb, som sikrede
os, at vi fange de sidste fejl.
\end{abstract}
\vfill
\columnbreak
\tableofcontents
\end{multicols}

\newpage
\pagestyle{fancy}
\section{Indledende}
Vi startede med at lave en single cycle, som vi lavede om til en pipeline, i
nedenstående afsnit har vi forklaret processen fra single cycle til pipeline.

\subsection{Instruktionssæt}
Vores pipelines instruktionssæt (\figref[fig:instruction-set]) er relativt
simpelt og indeholder `kun' 14 instruktioner. På følgende tabel er disse
instruktioner blevet beskrevet kort.

\begin{figure}[H]
        \begin{multicols}{2}
        \center

        \textbf{Arithmetic-logical} \\
        \vspace{0.15in}
        \begin{tabular}{|l|l|l|l|}
                \hline
                \scriptsize {\bf Mnemonic} &
                \scriptsize {\bf Code} &
                \scriptsize {\bf Type} &
                \scriptsize {\bf Description} \\
                \hline {\tt addu} & {\tt 0x21} & {\tt R} &
				\scriptsize Add unsigned \\
                \hline {\tt addiu} & {\tt 0x09} & {\tt I} &
				\scriptsize Add imm. unsigned \\
                \hline {\tt slt} & {\tt 0x2A} & {\tt R} &
				\scriptsize Set less than \\
                \hline {\tt slti} & {\tt 0x0A} & {\tt I} &
				\scriptsize Set imm. less than \\
                \hline {\tt subu} & {\tt 0x23} & {\tt R} &
				\scriptsize Subtract unsigned \\
                \hline {\tt and} & {\tt 0x24} & {\tt R} &
				\scriptsize Logical AND \\
                \hline {\tt andi} & {\tt 0x0C} & {\tt I} &
				\scriptsize Logical imm. AND \\
                \hline {\tt or} & {\tt 0x25} & {\tt R} &
				\scriptsize Logical OR \\
                \hline {\tt ori} & {\tt 0x0D} & {\tt I} &
				\scriptsize Logical imm. OR \\
                \hline
        \end{tabular}
        
        \columnbreak
        \center

        \textbf{Memory-reference} \\
        \vspace{0.15in}
        \begin{tabular}{|l|l|l|l|}
                \hline
                \scriptsize {\bf Mnemonic} &
                \scriptsize {\bf Code} &
                \scriptsize {\bf Type} &
                \scriptsize {\bf Description} \\
                \hline {\tt lw} & {\tt 0x23} & {\tt I} &
				\scriptsize Load word \\
                \hline {\tt sw} & {\tt 0x2B} & {\tt I} &
				\scriptsize Store word \\
                \hline
        \end{tabular}

        \vspace{0.26in} % to align the bottoms of the tables
        \textbf{Branching} \\
        \vspace{0.15in}
        \begin{tabular}{|l|l|l|l|}
                \hline
                \scriptsize {\bf Mnemonic} &
                \scriptsize {\bf Code} &
                \scriptsize {\bf Type} &
                \scriptsize {\bf Description} \\
                \hline {\tt beq} & {\tt 0x04} & {\tt I} &
				\scriptsize Branch on equal \\
                \hline {\tt jal} & {\tt 0x03} & {\tt J} &
				\scriptsize Jump and link \\
                \hline {\tt jr} & {\tt 0x08} & {\tt R} &
				\scriptsize Jump to register \\
                \hline
        \end{tabular}

        \end{multicols}
        \caption{Instruktionssæt}
        \label{fig:instruction-set}
\end{figure}

\subsection{Implementering af Single-cycle}
Da vi mødtes første gang tog vi simpelthen udgangspunkt i et helt nyt
kredsløb, og byggede et en fungerende {\it single-cycle} implementation af
den delmængde af MIPS instruktionssættet, som vi skulle understøtte jvf.
opgaveteksten i vores løsning.

Vi fik således alle instruktioner til at virke korrekt på første dag, undtagen
instruktionerne {\tt jal} og {\tt jr}. Disse blev implementeret umiddelbart
dagen efter.

\subsection{Konvertering til Pipeline}
Da {\it single-cycle} kredsløbet fungerede korrekt indførte vi {\it pipes},
som er mellem-registrer, hvori vi midlertidigt gemmer værdier beregnet i,
eller overført fra, sidste stadie (eg. {\tt IF/ID}, hvorfra vi viderefører
{\it program counter} (PC) efter at have beregnet den følgende instruktions
adresse, den nuværende instruktion, samt returneringsadressen for {\it jumps}
og et {\it stall}-signal.   

Vi introducerede alle {\it pipes} på én gang, da det var svært at se, hvordan
vi skulle have håndteret en halvt indført pipeline, og tog de fejl som det
medførte en efter en, herunder; at rykke {\it branch}-delen op i
{\it pipelinen} (i {\tt IF}-stadiet), hvilket medbragte den fordel, at vi ikke
skulle tænke så meget over {\it branch-delay slot}, i og med, at den følgende
{\it fetched} instruktion gerne skulle udføres, men PC derefter er blevet
ændret til {\it branch}-adressen.

\subsection{Forwarding og Hazard Detection}
Da de indledende fejl fra konverteringen var blevet reduceret og vi fik et
overskueligt overblik over kredsløbet igen, påbegyndte vi at tage os af
{\it hazards}, hvoraf vi tog os af de nemmeste og mest åbenlyse problemer
først, herunder; forwarding for de aritmetiske operationer (eg. {\tt addiu}
og {\tt subu}), og derefter {\it hazard-detection} og {\it stall} for
{\it memory} operationer (eg. {\tt sw} og {\tt lw}).

Til sidst tog vi os af {\it jumps} og {\it branches}, hvilket viste sig at
være mere udfordrende end først antaget, og også årsagen til, at vi må
erkende, at vores kredsløb har nogle fejl på dette område.

For det første er {\tt jal} implementeret sådan, at {\tt ID}-trinnet
håndterer både hvilken værdi der skal skrives i returregistret (sendt direkte
fra {\tt IF}-trinnet), samt signalet til rent faktisk at skrive. Dette har
den ulempe, at hvis en instruktion senere i pipen (fx. en {\tt addu}) forsøger
at skrive til registret, vil dette være 'optaget' og det vil kun være
retur-addressen der bliver skrevet. Dette kunne muligvis løses ved {\it hazard
detection}, der kunne stalle hele pipelinen et enkelt trin, så begge værdier
kunne nå at blive skrevet. Dette har vi desværre ikke nået at implementere.
Bortset fra denne ulempe fungerer {\tt jal} dog som den skal.

Derudover er {\tt jr} også implementeret uden {\it hazard detection} og
{\it forwarding}, hvilket medfører at en instruktion der forsøger at skrive
til register {\tt \$31} ({\tt \$ra}), ikke vil nå igennem pipen før {\tt jr}
udføres. Hvis man her antager, at assembler-programmøren følger MIPS
konventionen og kun skriver til {\tt \$ra} med {\tt jal}, vil dette ikke
blive et problem, eftersom {\tt jal} allerede skriver til registret i
{\tt ID}-trinnet.

\subsection{Done og virker}
hvad virker og hvorfor virker det (aka se test)

\subsection{Fejl og mangler}
Har vi noget der ikke virker og hvordan har vi tænkt os at implimentere det.

\newpage
\pagestyle{fancy}
\section{Tests}
Lige til, dog skal vi lave nogle gode test. Lad os komme med nogle nice ideer og så skrive hvordan de virker og giv resultatet. Husk forventet output og faktisk output.
\begin{figure}[h!]
        \begin{tabular}{ | l | l | l | l |}
                \hline
                $ .\$ 0$ & $00000000$  &  $ .\$ 16$ & $00000000$ \\
                \hline
                $ .\$ 1$ & $00000000$  &  $ .\$ 17$ & $00000000$ \\
                \hline
                $ .\$ 2$ & $00000000$  &  $ .\$ 18$ & $00000000$ \\
                \hline
                $ .\$ 3$ & $00000000$  &  $ .\$ 19$ & $00000000$ \\
                \hline
                $ .\$ 4$ & $00000000$  &  $ .\$ 20$ & $00000000$ \\
                \hline
                $ .\$ 5$ & $00000000$  &  $ .\$ 21$ & $00000000$ \\
                \hline
                $ .\$ 6$ & $00000000$  &  $ .\$ 22$ & $00000000$ \\
                \hline
                $ .\$ 7$ & $00000000$  &  $ .\$ 23$ & $00000000$ \\
                \hline
                $ .\$ 8$ & $00000000$  &  $ .\$ 24$ & $00000000$ \\
                \hline
                $ .\$ 9$ & $00000000$  &  $ .\$ 25$ & $00000000$ \\
                \hline
                $ .\$ 10$ & $00000000$  &  $ .\$ 26$ & $00000000$ \\
                \hline
                $ .\$ 11$ & $00000000$  &  $ .\$ 27$ & $00000000$ \\
                \hline
                $ .\$ 12$ & $00000000$  &  $ .\$ 28$ & $00000000$ \\
                \hline
                $ .\$ 13$ & $00000000$  &  $ .\$ 29$ & $00000000$ \\
                \hline
                $ .\$ 14$ & $00000000$  &  $ .\$ 30$ & $00000000$ \\
                \hline
                $ .\$ 15$ & $00000000$  &  $ .\$ 31$ & $00000000$ \\
                \hline
        \end{tabular}
        \caption{Forventet resultat}
        \label{fig:resultat0}
\end{figure}

\subsection{Aritmetiske og logiske operationer}
Ved at sammenligne 

\begin{multicols}{2}
\noindent I det følgende udregnes $((3+4)+7)-3$.
\lstinputlisting{tests/arithmetic.asm}
\vfill
\columnbreak
\lstset{language=[mips]Assembler}
\begin{figure}[H]
	\center
	\begin{tabular}{|l|l|l|l|}
		\hline
    	$ .\$zero$ & $00000000$  &  $ .\$ 16$ & $00000000$ \\
		\hline
		$ .\$ 1$ & $00000000$  &  $ .\$ 17$ & $00000000$ \\
		\hline
		$ .\$ 2$ & $00000000$  &  $ .\$ 18$ & $00000000$ \\
		\hline
		$ .\$ 3$ & $00000000$  &  $ .\$ 19$ & $00000000$ \\
		\hline
		$ .\$ 4$ & $00000000$  &  $ .\$ 20$ & $00000000$ \\
		\hline
		$ .\$ 5$ & $00000000$  &  $ .\$ 21$ & $00000000$ \\
		\hline
		$ .\$ 6$ & $00000000$  &  $ .\$ 22$ & $00000000$ \\
		\hline
		$ .\$ 7$ & $00000000$  &  $ .\$ 23$ & $00000000$ \\
		\hline
		$ .\$ 8$ & $00000000$  &  $ .\$ 24$ & $00000000$ \\
		\hline
		$ .\$ 9$ & $00000000$  &  $ .\$ 25$ & $00000000$ \\
		\hline
		$ .\$ 10$ & $00000000$  &  $ .\$ 26$ & $00000000$ \\
		\hline
		$ .\$ 11$ & $00000000$  &  $ .\$ 27$ & $00000000$ \\
		\hline
		$ .\$ 12$ & $00000000$  &  $ .\$ 28$ & $00000000$ \\
		\hline
		$ .\$ 13$ & $00000000$  &  $ .\$ 29$ & $00000000$ \\
		\hline
		$ .\$ 14$ & $00000000$  &  $ .\$ 30$ & $00000000$ \\
		\hline
		$ .\$ 15$ & $00000000$  &  $ .\$ra$ & $00000000$ \\
		\hline
	\end{tabular}
	\caption{Forventet resultat}
	\label{fig:resultat0}
\end{figure}
...
\end{multicols}

\subsection{Memory-reference operations}
\begin{multicols}{2}
\noindent ...
\vfill
\columnbreak
...
\lstset{language=[mips]Assembler}
% \lstinputlisting{tests/memref.asm}
...
\end{multicols}

\subsection{Branching operations}
...

\subsubsection{Hazards}
\begin{multicols}{2}
\noindent ...
\vfill
\columnbreak
...
\lstset{language=[mips]Assembler}
% \lstinputlisting{tests/branching.asm}
...
\end{multicols}

\newpage
\pagestyle{fancy}
\begin{thebibliography}{9}

\bibitem{cod}
  David A. Patterson, John L. Hennessy,
  \emph{Computer Organization and Design}.
  Morgan Kaufmann,
  Revised 4th Edition,
  2009.

\end{thebibliography}

\end{document}
